version: "3.3"

#networks:
#  traefik_proxy:
#    external: true

services:
  # webserver to handle all traffic. This can use let's encrypt to generate a SSL cert.
  traefik:
    # The official v2 Traefik docker image
    image: traefik:v2.9
    # Enables the web UI and tells Traefik to listen to docker
    command:
      #- "--log.level=DEBUG"
      - --api.insecure=false
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --entrypoints.websecure.address=:443
      - --certificatesresolvers.myresolver.acme.tlschallenge=true
      #- "--certificatesresolvers.myresolver.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory"
      - --certificatesresolvers.myresolver.acme.email=devops.isda@illinois.edu
      - --certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json
        #networks:
        #- traefik_proxy
    labels:
      - traefik.enable=true
      - traefik.http.routers.traefik_https.rule= Host(`traefik.smm-tester.ncsa.illinois.edu`)
      - traefik.http.routers.traefik_https.entrypoints=websecure
      - traefik.http.routers.traefik_https.tls=true
      - traefik.http.routers.traefik_https.tls.certResolver=myresolver
      - traefik.http.routers.traefik_https.service=api@internal
    dns:
      - 1.1.1.1
      - 1.0.0.1
    ports:
      # The HTTP port
      - "80:80"
      - "443:443"
      # The Web UI (enabled by --api.insecure=true)
      - "8080:8080"
    volumes:
      # So that Traefik can listen to the Docker events
      - /home/ywkim/workspace-smm/standalone-smm-analytics/rabbitmq/data/certbot/conf:/letsencrypt
      - /var/run/docker.sock:/var/run/docker.sock:ro

        #  whoami:
        #    image: traefik/whoami
        #    container_name: simple-service
        #    labels:
        #      - traefik.enable=true
        #      - traefik.http.routers.whoami.rule=Host(`smm-tester.ncsa.illinois.edu`)
        #      - traefik.http.routers.whoami.entrypoints=websecure
        #      - traefik.http.routers.whoami.tls.certresolver=myresolver
   
  rabbitmq:
    image: rabbitmq:3-management
    ports:
    - "5672:5672"
    - "15672:15672"

  minio:
    image: minio/minio
    hostname: minio
    #depends_on:
    #- traefik
      #    labels:
      #- traefik.enable=true
      #- traefik.http.routers.minio.service=minio
      #- traefik.http.routers.minio.rule=Host('s3.smm-tester.ncsa.illinois.edu') && (PathPrefix(`/`) || PathPrefix(`/{any:.*}/`) && (Headers(`hash`) || Headers(`9001`))
      #- traefik.http.routers.minio.entrypoints=websecure
      #- traefik.http.routers.minio.tls=true
      #- traefik.http.routers.minio.tls.certResolver=myresolver
      #- traefik.http.services.minio.loadbalancer.server.port=9000
      #- traefik.http.services.minio.loadbalancer.passhostheader=true
    # Minio Console
    #- traefik.http.routers.minio.rule=Host(`minio.smm-tester.ncsa.illinois.edu`)
    #- traefik.http.routers.minio.tls=true"
    #- traefik.http.routers.minio.tls.certresolver=resolver
    #- traefik.http.routers.minio.service=minioService
    #- traefik.http.services.minioService.loadbalancer.server.port=9001
    #- traefik.http.services.minioService.loadbalancer.passhostheader=true
    # Minio itself
    #- traefik.http.routers.cdn.rule=Host(`cdn.smm-tester.ncsa.illinois.edu`)
    #- traefik.http.routers.cdn.tls=true
    #- traefik.http.routers.cdn.tls.certresolver=resolver
    #- traefik.http.routers.cdn.service=cdnService
    #- traefik.http.services.cdnService.loadbalancer.server.port=9000
    #- traefik.http.services.cdnService.loadbalancer.passhostheader=true
    ports:
    - "9000:9000"
    - "9001:9001"
    volumes:
    - "smile_content_data:/tmp"
    command: server --console-address ":9001" /tmp
    environment:
    - MINIO_ACCESS_KEY=${AWS_ACCESSKEY}
    - MINIO_SECRET_KEY=${AWS_ACCESSKEYSECRET}
    restart: unless-stopped

  redis:
    image: redis
    hostname: redis
    ports:
    - "6379:6379"
    restart: unless-stopped

    #  nginx:
    #build: ./nginx
    #volumes:
    #  - ./data/certbot/conf:/etc/letsencrypt
    #  - ./data/certbot/www:/var/www/certbot
    #ports:
    #  - 80:80
    #  - 443:443
    #depends_on:
    #  - smile-server
    #command: "/bin/sh -c 'while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"
    #restart: unless-stopped

    #certbot:
    #image: certbot/certbot
    #volumes:
    #  - ./data/certbot/conf:/etc/letsencrypt
    #  - ./data/certbot/www:/var/www/certbot
    #entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
    #restart: unless-stopped

  algorithm-classification-predict:
#    build: ./classification_predict
    image: socialmediamacroscope/classification_predict:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=classification_predict
    restart: unless-stopped

  algorithm-classification-split:
#    build: ./classification_split
    image: socialmediamacroscope/classification_split:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=classification_split
    restart: unless-stopped

  algorithm-classification-train:
#    build: ./classification_train
    image: socialmediamacroscope/classification_train:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=classification_train
    restart: unless-stopped

  algorithm-histogram:
#    build: ./histogram
    image: socialmediamacroscope/histogram:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=histogram
    restart: unless-stopped

  algorithm-network-analysis:
#    build: ./network_analysis
    image: socialmediamacroscope/network_analysis:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=network_analysis
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    restart: unless-stopped

  algorithm-preprocessing:
#    build: ./preprocessing
    image: socialmediamacroscope/preprocessing:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=preprocessing
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    restart: unless-stopped

  algorithm-sentiment-analysis:
#    build: ./sentiment_analysis
    image: socialmediamacroscope/sentiment_analysis:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=sentiment_analysis
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    restart: unless-stopped

  algorithm-screen-name-prompt:
#    build: ./screen_name_prompt
    image: socialmediamacroscope/screen_name_prompt:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./screen_name_prompt.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=bae_screen_name_prompt
    restart: unless-stopped

  algorithm-topic-modeling:
#    build: ./topic_modeling
    image: socialmediamacroscope/topic_modeling:latest
    depends_on:
    - rabbitmq
    - minio
    command: python ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=topic_modeling
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    restart: unless-stopped

  algorithm-name-entity-recognition:
#    build: ./name_entity_recognition
    image: socialmediamacroscope/name_entity_recognition:latest
    depends_on:
    - rabbitmq
    - minio
    command: python3 ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=name_entity_recognition
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    restart: unless-stopped

  algorithm-autophrase:
#    build: ./autophrase
    image: socialmediamacroscope/autophrase:latest
    depends_on:
    - rabbitmq
    - minio
    command: python3 ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=autophrase
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    restart: unless-stopped

  image-crawler:
#    build: ./image_crawler
    image: socialmediamacroscope/image_crawler:latest
    depends_on:
    - rabbitmq
    - minio
    command: python3 ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=image_crawler
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    restart: unless-stopped

  collect-reddit-comment:
#    build: ./collect_reddit_comment
    image: socialmediamacroscope/collect_reddit_comment:latest
    depends_on:
    - rabbitmq
    - minio
    command: python3 ./rabbitmq_handler.py
    environment:
    - HOST_IP=${HOST_IP}
    - REDDIT_CLIENT_ID=${REDDIT_CLIENT_ID}
    - REDDIT_CLIENT_SECRET=${REDDIT_CLIENT_SECRET}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - BUCKET_NAME=${BUCKET_NAME}
    - QUEUE_NAME=reddit_comment
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    restart: unless-stopped

  smile-server:
#    build: /Users/cwang138/Documents/Macroscope/SMILE/www
#image: socialmediamacroscope/smile_server:cilogon-alpha
    image: socialmediamacroscope/smile_server:minio_no_port
    depends_on:
    - traefik        
    - rabbitmq
    - minio
    - redis
    - algorithm-classification-predict
    - algorithm-classification-split
    - algorithm-classification-train
    - algorithm-histogram
    - algorithm-network-analysis
    - algorithm-preprocessing
    - algorithm-sentiment-analysis
    - algorithm-autophrase
    - algorithm-name-entity-recognition
    - algorithm-topic-modeling
    - algorithm-screen-name-prompt
    - image-crawler
    labels:
    - traefik.enable=true
    - traefik.http.routers.smile_server.rule=Host(`smm-tester.ncsa.illinois.edu`) && PathPrefix(`/`)
    - traefik.http.routers.smile_server.entrypoints=websecure
    - traefik.http.routers.smile_server.tls.certresolver=myresolver
    ports:
    - "8001:8001"
    command: npm run docker-start
    environment:
    - HOME=${HOME}
    - DOCKERIZED=${DOCKERIZED}
    - LOCAL_ALGORITHM=${LOCAL_ALGORITHM}
    - HOST_IP=${HOST_IP}
    - BUCKET_NAME=${BUCKET_NAME}
    - AWS_ACCESSKEY=${AWS_ACCESSKEY}
    - AWS_ACCESSKEYSECRET=${AWS_ACCESSKEYSECRET}
    - TWITTER_CONSUMER_KEY=${TWITTER_CONSUMER_KEY}
    - TWITTER_CONSUMER_SECRET=${TWITTER_CONSUMER_SECRET}
    - REDDIT_CLIENT_ID=${REDDIT_CLIENT_ID}
    - REDDIT_CLIENT_SECRET=${REDDIT_CLIENT_SECRET}
    - BOX_CLIENT_ID=${BOX_CLIENT_ID}
    - BOX_CLIENT_SECRET=${BOX_CLIENT_SECRET}
    - DROPBOX_CLIENT_ID=${DROPBOX_CLIENT_ID}
    - DROPBOX_CLIENT_SECRET=${DROPBOX_CLIENT_SECRET}
    - GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
    - GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
    - EMAIL_HOST=${EMAIL_HOST}
    - EMAIL_PORT=${EMAIL_PORT}
    - EMAIL_FROM_ADDRESS=${EMAIL_FROM_ADDRESS}
    - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    - SINGLE_USER=${SINGLE_USER}
    - CILOGON_CLIENT_ID=${CILOGON_CLIENT_ID}
    - CILOGON_CLIENT_SECRET=${CILOGON_CLIENT_SECRET}
    - CILOGON_CALLBACK_URL=${CILOGON_CALLBACK_URL}
    volumes:
    - "smile_content_data:/tmp"
    - "smile_tag:${HOME}/smile"
    restart: unless-stopped

  smile-graphql:
#    build: /Users/cwang138/Documents/Macroscope/SMILE/www/graphql
    image: socialmediamacroscope/smile_graphql:latest
    depends_on:
    - smile-server
    ports:
    - "5050:5050"
    command: npm run docker-start
    environment:
    - DOCKERIZED=${DOCKERIZED}
    - TWITTER_CONSUMER_KEY=${TWITTER_CONSUMER_KEY}
    - TWITTER_CONSUMER_SECRET=${TWITTER_CONSUMER_SECRET}
    restart: unless-stopped

volumes:
  smile_content_data:
    driver: local
    driver_opts:
      o: bind
      type: none
      # put your own local data path here
      device: "${HOME}/smile_data"

  smile_user:
    driver: local
    driver_opts:
      o: bind
      type: none
      device: "${HOME}/smile_user"

  smile_tag:
    driver: local
    driver_opts:
      o: bind
      type: none
      device: "${HOME}/smile"
